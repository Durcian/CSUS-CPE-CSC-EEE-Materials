#include <stdio.h>#include <stdlib.h>#include <pthread.h>#include <sys/timeb.h>#include <semaphore.h>#define MAX_SIZE 100000000#define MAX_THREADS 16#define RANDOM_SEED 7654#define MAX_RANDOM_NUMBER 5000// Global variableslong gRefTime; //For timingint gData[MAX_SIZE]; //The array that will hold the dataint gThreadCount; //Number of threadsint gDoneThreadCount; //Number of threads that are done at a certain point. Whenever a thread is done, it increments this. Used with the semaphore-based solutionint gThreadMin[MAX_THREADS]; //The minimum value found by each threadbool gThreadDone[MAX_THREADS]; //Is this thread done? Used when the parent is continually checking on child threads// Semaphoressem_t completed; //To notify parent that all threads have completed or one of them found a zerosem_t mutex; //Binary semaphore to protect the shared variable gDoneThreadCountint SqFindMin(int size); //Sequential FindMin (no threads)void *ThFindMin(void *param); //Thread FindMin but without semaphoresvoid *ThFindMinWithSemaphore(void *param); //Thread FindMin with semaphoresint SearchThreadMin(); // Search all thread minima to find the minimum value found in all threadsvoid InitSharedVars();void GenerateInput(int size, int indexForZero); //Generate the input arrayvoid CalculateIndices(int arraySize, int thrdCnt, int indices[MAX_THREADS][3]); //Calculate the indices to divide the array into T divisions, one division per threadint GetRand(int min, int max);//Get a random number between min and max//Timing functionslong GetMilliSecondTime(struct timeb timeBuf);long GetCurrentTime(void);void SetTime(void);long GetTime(void);int main(int argc, char *argv[]){pthread_t tid[MAX_THREADS];pthread_attr_t attr[MAX_THREADS];int indices[MAX_THREADS][3];int i, indexForZero, arraySize, min;
// Code for parsing and checking command-line argumentsif(argc != 4){fprintf(stderr, "Invalid number of arguments!\n");exit(-1);}if((arraySize = atoi(argv[1])) <= 0 || arraySize > MAX_SIZE){fprintf(stderr, "Invalid Array Size\n");exit(-1);}gThreadCount = atoi(argv[2]);if(gThreadCount > MAX_THREADS || gThreadCount <=0){fprintf(stderr, "Invalid Thread Count\n");exit(-1);}indexForZero = atoi(argv[3]);if(indexForZero < -1 || indexForZero >= arraySize){fprintf(stderr, "Invalid index for zero!\n");exit(-1);}GenerateInput(arraySize, indexForZero);CalculateIndices(arraySize, gThreadCount, indices);// Code for the sequential partSetTime();min = SqFindMin(arraySize);printf("Sequential search completed in %ld ms. Min = %d\n", GetTime(), min);// Threaded with parent waiting for all child threadsInitSharedVars();SetTime();// Write your code here// Initialize threads, create threads, and then let the parent wait for all threads using pthread_join// The thread start function is ThFindMin// Don't forget to properly initialize shared variablesmin = SearchThreadMin();printf("Threaded FindMin with parent waiting for all children completed in %ld ms. Min = %d\n", GetTime(), min);// Multi-threaded with busy waiting (parent continually checking on child threads without using semaphores)InitSharedVars();SetTime();// Write your code here
// Don't use any semaphores in this part// Initialize threads, create threads, and then make the parent continually check on all child threads// The thread start function is ThFindMin// Don't forget to properly initialize shared variablesmin = SearchThreadMin();printf("Threaded FindMin with parent continually checking on children completed in %ld ms. Min = %d\n", GetTime(), min);// Multi-threaded with semaphoresInitSharedVars();// Initialize your semaphores hereSetTime();// Write your code here// Initialize threads, create threads, and then make the parent wait on the "completed" semaphore// The thread start function is ThFindMinWithSemaphore// Don't forget to properly initialize shared variables and semaphores using sem_initmin = SearchThreadMin();printf("Threaded FindMin with parent waiting on a semaphore completed in %ld ms. Min = %d\n", GetTime(), min);}// Write a regular sequential function to search for the minimum value in the array gDataint SqFindMin(int size) {}// Write a thread function that searches for the minimum value in one division of the array// When it is done, this function should put the minimum in gThreadMin[threadNum] and set gThreadDone[threadNum] to truevoid* ThFindMin(void *param) {int threadNum = ((int*)param)[0];}// Write a thread function that searches for the minimum value in one division of the array// When it is done, this function should put the minimum in gThreadMin[threadNum]// If the minimum value in this division is zero, this function should post the "completed" semaphore
// If the minimum value in this division is not zero, this function should increment gDoneThreadCount and// post the "completed" semaphore if it is the last thread to be done// Don't forget to protect access to gDoneThreadCount with the "mutex" semaphorevoid* ThFindMinWithSemaphore(void *param) {}int SearchThreadMin() {int i, min = MAX_RANDOM_NUMBER + 1;for(i =0; i<gThreadCount; i++) {if(gThreadMin[i] == 0)return 0;if(gThreadDone[i] == true && gThreadMin[i] < min)min = gThreadMin[i];}return min;}void InitSharedVars() {int i;for(i=0; i<gThreadCount; i++){gThreadDone[i] = false;gThreadMin[i] = MAX_RANDOM_NUMBER + 1;}gDoneThreadCount = 0;}// Write a function that fills the gData array with random numbers between 1 and MAX_RANDOM_NUMBER// If indexForZero is valid and non-negative, set the value at that index to zerovoid GenerateInput(int size, int indexForZero) {}// Write a function that calculates the right indices to divide the array into thrdCnt equal divisions// For each division i, indices[i][0] should be set to the division number i,// indices[i][1] should be set to the start index, and indices[i][2] should be set to the end indexvoid CalculateIndices(int arraySize, int thrdCnt, int indices[MAX_THREADS][3]) {}// Get a random number in the range [x, y]int GetRand(int x, int y) {int r = rand();r = x + r % (y-x+1);
return r;}long GetMilliSecondTime(struct timeb timeBuf){long mliScndTime;mliScndTime = timeBuf.time;mliScndTime *= 1000;mliScndTime += timeBuf.millitm;return mliScndTime;}long GetCurrentTime(void){long crntTime=0;struct timeb timeBuf;ftime(&timeBuf);crntTime = GetMilliSecondTime(timeBuf);return crntTime;}void SetTime(void){gRefTime = GetCurrentTime();}long GetTime(void){long crntTime = GetCurrentTime();return (crntTime - gRefTime);}